/**
 * =============================================================================
 * METHOD TAB - L5/L6 Premium Multi-Mode Recipe Viewer
 * =============================================================================
 * 
 * THREE VIEWING MODES (unified switcher):
 * 
 * 1. COMPACT MODE (default)
 *    - Dense accordion cards for daily kitchen ops
 *    - Quick reference, minimal scrolling
 *    - Functional, get-it-done aesthetic
 * 
 * 2. GUIDED MODE (magazine style)
 *    - HORIZONTAL SIDE-SCROLLING like a cookbook
 *    - Starts INLINE in content area
 *    - Optional fullscreen with F key or button
 *    - L5 SUBTLE GREY PALETTE - images are the star
 * 
 * 3. FOCUS MODE (fullscreen)
 *    - One step at a time, immersive
 *    - IMMEDIATELY enters fullscreen on click
 *    - Timer + navigation in bottom action bar
 *    - Designed for wet/floury hands during cooking
 * 
 * L5 COLOR PHILOSOPHY:
 * - Food photos are the HERO - UI gets out of the way
 * - Subtle grey palette: neutral-950, neutral-900, neutral-800
 * - Brand amber ONLY for navigation accents
 * - Elegant restraint over visual noise
 * 
 * =============================================================================
 */

import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { 
  Book, 
  Maximize2,
  Minimize2,
  ChevronLeft, 
  ChevronRight,
  ChevronDown,
  Check,
  X,
  Play,
  Pause,
  RotateCcw,
  Timer,
  Lightbulb,
  AlertTriangle,
  AlertOctagon,
  Info,
  Thermometer,
  RotateCcw as FifoIcon,
  ShieldAlert,
  Clock,
  Flame,
  Snowflake,
  CheckCircle,
  Eye,
  Utensils,
  Circle,
  ListOrdered,
  Image as ImageIcon,
  ZoomIn,
  Hourglass,
  LayoutList,
  BookOpen,
  Focus,
  ChefHat,
} from "lucide-react";
import { useDiagnostics } from "@/hooks/useDiagnostics";
import { getActiveInstructionBlocks, type InstructionBlockTemplate } from "@/features/recipes/hooks/useRecipeConfig";
import type { Recipe, RecipeStep, RecipeMedia, RecipeStage } from "../../../types/recipe";

// ============================================================================
// TYPES
// ============================================================================

interface MethodProps {
  recipe: Recipe;
}

type ViewMode = 'compact' | 'guided' | 'focus';

interface StepsByStage {
  stage: RecipeStage | null;
  steps: Array<{ step: RecipeStep; originalIndex: number }>;
}

// ============================================================================
// ICON MAP for Callouts
// ============================================================================

const CALLOUT_ICONS: Record<string, React.ElementType> = {
  Lightbulb,
  AlertTriangle,
  AlertOctagon,
  Info,
  RotateCcw: FifoIcon,
  Thermometer,
  ShieldAlert,
  Clock,
  Flame,
  Snowflake,
  CheckCircle,
  Eye,
  Utensils,
};

// ============================================================================
// CALLOUT COLOR CONFIG
// ============================================================================

const CALLOUT_COLORS: Record<string, { bg: string; border: string; icon: string; text: string }> = {
  emerald: { bg: 'bg-emerald-950/60', border: 'border-l-emerald-500', icon: 'text-emerald-400', text: 'text-emerald-100' },
  amber: { bg: 'bg-amber-950/60', border: 'border-l-amber-500', icon: 'text-amber-400', text: 'text-amber-100' },
  rose: { bg: 'bg-rose-950/60', border: 'border-l-rose-500', icon: 'text-rose-400', text: 'text-rose-100' },
  blue: { bg: 'bg-blue-950/60', border: 'border-l-blue-500', icon: 'text-blue-400', text: 'text-blue-100' },
  cyan: { bg: 'bg-cyan-950/60', border: 'border-l-cyan-500', icon: 'text-cyan-400', text: 'text-cyan-100' },
  orange: { bg: 'bg-orange-950/60', border: 'border-l-orange-500', icon: 'text-orange-400', text: 'text-orange-100' },
  purple: { bg: 'bg-purple-950/60', border: 'border-l-purple-500', icon: 'text-purple-400', text: 'text-purple-100' },
  lime: { bg: 'bg-lime-950/60', border: 'border-l-lime-500', icon: 'text-lime-400', text: 'text-lime-100' },
  pink: { bg: 'bg-pink-950/60', border: 'border-l-pink-500', icon: 'text-pink-400', text: 'text-pink-100' },
  teal: { bg: 'bg-teal-950/60', border: 'border-l-teal-500', icon: 'text-teal-400', text: 'text-teal-100' },
  primary: { bg: 'bg-primary-950/60', border: 'border-l-primary-500', icon: 'text-primary-400', text: 'text-primary-100' },
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function extractStepTitle(instruction: string, customLabel?: string | null): string {
  if (customLabel) return customLabel;
  
  const plainText = instruction.replace(/<[^>]*>/g, '').trim();
  const colonIndex = plainText.indexOf(':');
  const periodIndex = plainText.indexOf('.');
  const newlineIndex = plainText.indexOf('\n');
  
  let breakPoint = 80;
  if (colonIndex > 0 && colonIndex < 60) breakPoint = Math.min(breakPoint, colonIndex);
  if (periodIndex > 0 && periodIndex < 80) breakPoint = Math.min(breakPoint, periodIndex);
  if (newlineIndex > 0 && newlineIndex < 80) breakPoint = Math.min(breakPoint, newlineIndex);
  
  const title = plainText.substring(0, breakPoint).trim();
  if (breakPoint < plainText.length && !title.endsWith(':') && !title.endsWith('.')) {
    return title + '...';
  }
  return title;
}

function formatDuration(minutes: number): string {
  if (minutes < 60) return `${minutes}m`;
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
}

function formatDelay(delay: { value: number; unit: string }): string {
  const { value, unit } = delay;
  if (unit === 'minutes') return `${value} min`;
  if (unit === 'hours') return `${value} hr${value !== 1 ? 's' : ''}`;
  if (unit === 'days') return `${value} day${value !== 1 ? 's' : ''}`;
  return `${value} ${unit}`;
}

function calculateTotalTime(steps: RecipeStep[]): number {
  return steps.reduce((total, step) => {
    let stepTime = step.time_in_minutes || 0;
    if (step.delay?.value) {
      const delayMins = step.delay.unit === 'hours' 
        ? step.delay.value * 60 
        : step.delay.unit === 'days' 
          ? step.delay.value * 60 * 24 
          : step.delay.value;
      stepTime += delayMins;
    }
    return total + stepTime;
  }, 0);
}

function groupStepsByStage(steps: RecipeStep[], stages: RecipeStage[] = []): StepsByStage[] {
  const groups: StepsByStage[] = [];
  
  const unstagedSteps = steps
    .map((step, index) => ({ step, originalIndex: index }))
    .filter(item => !item.step.stage_id);
  
  if (unstagedSteps.length > 0) {
    groups.push({ stage: null, steps: unstagedSteps });
  }
  
  stages.forEach(stage => {
    const stageSteps = steps
      .map((step, index) => ({ step, originalIndex: index }))
      .filter(item => item.step.stage_id === stage.id);
    
    if (stageSteps.length > 0) {
      groups.push({ stage, steps: stageSteps });
    }
  });
  
  return groups;
}

// ============================================================================
// MEDIA GALLERY COMPONENT
// ============================================================================

interface MediaGalleryProps {
  media: RecipeMedia[];
  size?: 'normal' | 'large';
  layout?: 'grid' | 'inline';
}

const MediaGallery: React.FC<MediaGalleryProps> = ({ media, size = 'normal', layout = 'grid' }) => {
  const [lightboxOpen, setLightboxOpen] = useState(false);
  const [lightboxIndex, setLightboxIndex] = useState(0);

  if (!media || media.length === 0) return null;

  const images = media.filter(m => m.type === 'image');
  const videos = media.filter(m => m.type === 'video' || m.type === 'external-video');

  const openLightbox = (index: number) => {
    setLightboxIndex(index);
    setLightboxOpen(true);
  };

  const thumbnailSize = size === 'large' ? 'w-24 h-24 sm:w-32 sm:h-32' : 'w-16 h-16 sm:w-20 sm:h-20';
  const gridCols = size === 'large' ? 'grid-cols-3 sm:grid-cols-4 lg:grid-cols-5' : 'grid-cols-4 sm:grid-cols-5';

  return (
    <>
      {images.length > 0 && (
        <div className={layout === 'inline' ? '' : 'mt-4'}>
          {layout === 'grid' && (
            <div className="flex items-center gap-2 mb-2">
              <ImageIcon className="w-4 h-4 text-gray-500" />
              <span className="text-xs font-medium text-gray-500 uppercase tracking-wider">
                Photos ({images.length})
              </span>
            </div>
          )}
          <div className={layout === 'inline' ? 'flex gap-2' : `grid ${gridCols} gap-2`}>
            {images.map((img, idx) => (
              <button
                key={img.id}
                onClick={() => openLightbox(idx)}
                className={`${layout === 'inline' ? 'w-20 h-20 sm:w-24 sm:h-24' : thumbnailSize} rounded-lg overflow-hidden bg-gray-800 border border-gray-700/50 hover:border-amber-500/50 transition-all group relative flex-shrink-0`}
              >
                <img 
                  src={img.url} 
                  alt={img.title || `Step image ${idx + 1}`}
                  className="w-full h-full object-cover"
                />
                <div className="absolute inset-0 bg-black/0 group-hover:bg-black/30 transition-all flex items-center justify-center">
                  <ZoomIn className="w-5 h-5 text-white opacity-0 group-hover:opacity-100 transition-opacity" />
                </div>
              </button>
            ))}
          </div>
        </div>
      )}

      {videos.length > 0 && (
        <div className="mt-4 space-y-3">
          {videos.map((vid) => (
            <div key={vid.id} className="rounded-lg overflow-hidden bg-gray-900 border border-gray-700/50">
              {vid.type === 'external-video' ? (
                <div className="aspect-video">
                  <iframe
                    src={vid.url}
                    className="w-full h-full"
                    frameBorder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowFullScreen
                  />
                </div>
              ) : (
                <video src={vid.url} className="w-full aspect-video object-cover" controls preload="metadata" />
              )}
              {vid.title && (
                <div className="px-3 py-2 border-t border-gray-700/50">
                  <p className="text-sm text-gray-400">{vid.title}</p>
                </div>
              )}
            </div>
          ))}
        </div>
      )}

      {lightboxOpen && images.length > 0 && (
        <div 
          className="fixed inset-0 z-[60] bg-black/95 flex items-center justify-center"
          onClick={() => setLightboxOpen(false)}
        >
          <button
            onClick={() => setLightboxOpen(false)}
            className="absolute top-4 right-4 w-10 h-10 rounded-full bg-gray-800 hover:bg-gray-700 flex items-center justify-center text-white z-10"
          >
            <X className="w-5 h-5" />
          </button>
          
          {images.length > 1 && (
            <>
              <button
                onClick={(e) => { e.stopPropagation(); setLightboxIndex(i => (i - 1 + images.length) % images.length); }}
                className="absolute left-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-gray-800/80 hover:bg-gray-700 flex items-center justify-center text-white"
              >
                <ChevronLeft className="w-6 h-6" />
              </button>
              <button
                onClick={(e) => { e.stopPropagation(); setLightboxIndex(i => (i + 1) % images.length); }}
                className="absolute right-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-gray-800/80 hover:bg-gray-700 flex items-center justify-center text-white"
              >
                <ChevronRight className="w-6 h-6" />
              </button>
            </>
          )}
          
          <div className="max-w-5xl max-h-[85vh] px-4" onClick={e => e.stopPropagation()}>
            <img 
              src={images[lightboxIndex].url} 
              alt={images[lightboxIndex].title || 'Step image'}
              className="max-w-full max-h-[80vh] object-contain rounded-lg"
            />
            {images[lightboxIndex].title && (
              <p className="text-center text-gray-300 mt-3">{images[lightboxIndex].title}</p>
            )}
            <p className="text-center text-gray-500 text-sm mt-1">
              {lightboxIndex + 1} of {images.length}
            </p>
          </div>
        </div>
      )}
    </>
  );
};

// ============================================================================
// HTML PARSER - Converts rich text HTML to renderable components
// ============================================================================

const RichTextRenderer: React.FC<{ 
  html: string; 
  blocks: InstructionBlockTemplate[];
  size?: 'normal' | 'large' | 'guided';
  subtle?: boolean;
}> = ({ html, blocks, size = 'normal', subtle = false }) => {
  if (!html || html === '<p></p>') {
    return <span className="text-gray-500 italic">No instructions</span>;
  }

  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  
  const renderNode = (node: Node, key: number): React.ReactNode => {
    if (node.nodeType === Node.TEXT_NODE) return node.textContent;
    if (node.nodeType !== Node.ELEMENT_NODE) return null;

    const element = node as Element;
    const tagName = element.tagName.toLowerCase();
    const children = Array.from(element.childNodes).map((child, i) => renderNode(child, i));

    const textSize = size === 'guided' 
      ? 'text-base sm:text-lg' 
      : size === 'large' 
        ? 'text-lg sm:text-xl lg:text-2xl' 
        : 'text-sm';
    
    const textColor = subtle ? 'text-neutral-300' : 'text-gray-300';

    switch (tagName) {
      case 'p':
        return <p key={key} className={`${textSize} ${textColor} leading-relaxed mb-3 last:mb-0`}>{children}</p>;
      case 'h2':
        return <h2 key={key} className={`${size === 'guided' ? 'text-lg sm:text-xl' : 'text-base'} font-semibold ${subtle ? 'text-neutral-100' : 'text-white'} mt-4 mb-2`}>{children}</h2>;
      case 'h3':
        return <h3 key={key} className={`${size === 'guided' ? 'text-base' : 'text-sm'} font-medium ${subtle ? 'text-neutral-200' : 'text-white'} mt-3 mb-1.5`}>{children}</h3>;
      case 'strong':
      case 'b':
        return <strong key={key} className={`font-semibold ${subtle ? 'text-neutral-100' : 'text-white'}`}>{children}</strong>;
      case 'em':
      case 'i':
        return <em key={key} className={`italic ${subtle ? 'text-neutral-200' : 'text-gray-200'}`}>{children}</em>;
      case 'u':
        return <u key={key} className={`underline ${subtle ? 'decoration-neutral-600' : 'decoration-amber-500/60'} decoration-2 underline-offset-2`}>{children}</u>;
      case 's':
      case 'strike':
        return <s key={key} className="line-through text-gray-500">{children}</s>;
      case 'mark':
        return <mark key={key} className={`${subtle ? 'bg-neutral-700/50 text-neutral-100' : 'bg-amber-500/30 text-amber-100'} px-1 rounded`}>{children}</mark>;
      case 'ul':
        return <ul key={key} className={`${textSize} list-none space-y-1.5 my-3 ml-1`}>{children}</ul>;
      case 'ol':
        return <ol key={key} className={`${textSize} list-none space-y-1.5 my-3 ml-1`}>{children}</ol>;
      case 'li':
        const isTask = element.getAttribute('data-type') === 'taskItem';
        const isChecked = element.getAttribute('data-checked') === 'true';
        
        if (isTask) {
          return (
            <li key={key} className={`flex items-start gap-2.5 ${isChecked ? 'opacity-60' : ''}`}>
              <span className={`mt-0.5 w-4 h-4 rounded border-2 flex items-center justify-center flex-shrink-0 ${isChecked ? 'bg-emerald-500/30 border-emerald-500 text-emerald-400' : subtle ? 'border-neutral-600' : 'border-gray-500'}`}>
                {isChecked && <Check className="w-2.5 h-2.5" />}
              </span>
              <span className={isChecked ? 'line-through text-gray-500' : textColor}>{children}</span>
            </li>
          );
        }
        
        const parentTag = element.parentElement?.tagName.toLowerCase();
        if (parentTag === 'ol') {
          return (
            <li key={key} className={`flex items-start gap-2.5 ${textColor}`}>
              <span className={`w-5 h-5 rounded-full ${subtle ? 'bg-neutral-800 text-neutral-500' : 'bg-gray-700/60 text-gray-400'} text-xs font-medium flex items-center justify-center flex-shrink-0 mt-0.5`}>{key + 1}</span>
              <span>{children}</span>
            </li>
          );
        }
        
        return (
          <li key={key} className={`flex items-start gap-2.5 ${textColor}`}>
            <span className={`w-1.5 h-1.5 rounded-full ${subtle ? 'bg-neutral-600' : 'bg-amber-500/60'} flex-shrink-0 mt-2`} />
            <span>{children}</span>
          </li>
        );
      case 'blockquote':
        return <blockquote key={key} className={`border-l-3 ${subtle ? 'border-neutral-700 text-neutral-400' : 'border-amber-500/40 text-gray-400'} pl-3 my-3 italic`}>{children}</blockquote>;
      case 'hr':
        return <hr key={key} className={subtle ? 'border-neutral-800' : 'border-gray-700'} />;
      case 'div':
        if (element.hasAttribute('data-callout')) {
          const calloutType = element.getAttribute('data-callout-type') || 'info';
          const blockConfig = blocks.find(b => b.type === calloutType);
          const colorConfig = CALLOUT_COLORS[blockConfig?.color || 'blue'] || CALLOUT_COLORS.blue;
          const IconComponent = CALLOUT_ICONS[blockConfig?.icon || 'Info'] || Info;
          const label = blockConfig?.label || calloutType;

          if (subtle) {
            return (
              <div key={key} className="relative my-4 pl-4 border-l-2 border-neutral-700">
                <div className="text-xs font-medium uppercase tracking-wider mb-1 text-neutral-500">{label}</div>
                <div className="text-sm sm:text-base text-neutral-400 leading-relaxed">{children}</div>
              </div>
            );
          }

          return (
            <div key={key} className={`rounded-lg border-l-4 p-3 my-3 ${colorConfig.bg} ${colorConfig.border}`}>
              <div className="flex items-center gap-2 mb-1.5">
                <div className={`w-5 h-5 rounded flex items-center justify-center ${colorConfig.icon}`} style={{ backgroundColor: 'rgba(255,255,255,0.1)' }}>
                  <IconComponent className="w-3 h-3" />
                </div>
                <span className={`text-xs font-bold uppercase tracking-wider ${colorConfig.icon}`}>{label}</span>
              </div>
              <div className={`${size === 'large' ? 'text-base sm:text-lg' : 'text-sm'} ${colorConfig.text} leading-relaxed`}>{children}</div>
            </div>
          );
        }
        return <div key={key}>{children}</div>;
      default:
        return <span key={key}>{children}</span>;
    }
  };

  return <div className="rich-text-content">{Array.from(doc.body.childNodes).map((node, i) => renderNode(node, i))}</div>;
};

// ============================================================================
// CONTROL POINT BADGES
// ============================================================================

interface ControlPointBadgesProps {
  step: RecipeStep;
  size?: 'small' | 'normal' | 'large';
  subtle?: boolean;
}

const ControlPointBadges: React.FC<ControlPointBadgesProps> = ({ step, size = 'normal', subtle = false }) => {
  const badges = [];
  
  if (step.is_critical_control_point) {
    badges.push({
      key: 'ccp',
      label: size === 'small' ? 'CCP' : 'Critical Control Point',
      color: subtle 
        ? 'bg-rose-500/10 text-rose-400/70 border-rose-500/20'
        : 'bg-rose-500/20 text-rose-400 border-rose-500/30',
      icon: ShieldAlert,
    });
  }
  
  if (step.is_quality_control_point) {
    badges.push({
      key: 'qcp',
      label: size === 'small' ? 'QCP' : 'Quality Control Point',
      color: subtle
        ? 'bg-amber-500/10 text-amber-400/70 border-amber-500/20'
        : 'bg-amber-500/20 text-amber-400 border-amber-500/30',
      icon: Eye,
    });
  }
  
  if (step.warning_level && step.warning_level !== 'low') {
    badges.push({
      key: 'warning',
      label: size === 'small' 
        ? (step.warning_level === 'high' ? '⚠️' : '⚡') 
        : `${step.warning_level === 'high' ? 'High' : 'Medium'} Safety`,
      color: step.warning_level === 'high' 
        ? subtle ? 'bg-red-500/10 text-red-400/70 border-red-500/20' : 'bg-red-500/20 text-red-400 border-red-500/30'
        : subtle ? 'bg-orange-500/10 text-orange-400/70 border-orange-500/20' : 'bg-orange-500/20 text-orange-400 border-orange-500/30',
      icon: AlertTriangle,
    });
  }
  
  if (badges.length === 0) return null;
  
  const badgeSize = size === 'small' ? 'px-1.5 py-0.5 text-[10px]' : size === 'large' ? 'px-3 py-1 text-sm' : 'px-2 py-0.5 text-xs';
  const iconSize = size === 'small' ? 'w-3 h-3' : size === 'large' ? 'w-4 h-4' : 'w-3.5 h-3.5';
  
  return (
    <div className="flex flex-wrap gap-2">
      {badges.map(badge => {
        const Icon = badge.icon;
        return (
          <span 
            key={badge.key}
            className={`inline-flex items-center gap-1.5 rounded-full border font-medium ${badgeSize} ${badge.color}`}
          >
            <Icon className={iconSize} />
            <span>{badge.label}</span>
          </span>
        );
      })}
    </div>
  );
};

// ============================================================================
// COMPACT MODE - Step Card Component
// ============================================================================

interface CompactStepCardProps {
  step: RecipeStep;
  index: number;
  blocks: InstructionBlockTemplate[];
  isExpanded: boolean;
  onToggle: () => void;
}

const CompactStepCard: React.FC<CompactStepCardProps> = ({ step, index, blocks, isExpanded, onToggle }) => {
  const title = extractStepTitle(step.instruction, step.custom_step_label);
  const hasControlPoints = step.is_critical_control_point || step.is_quality_control_point || (step.warning_level && step.warning_level !== 'low');
  const hasMedia = step.media && step.media.length > 0;
  const mediaCount = step.media?.length || 0;
  
  return (
    <div className={`rounded-xl overflow-hidden border transition-all duration-300 ${
      hasControlPoints 
        ? `border-rose-500/30 ${isExpanded ? 'bg-gray-800/50' : 'bg-gray-800/30'}` 
        : isExpanded 
          ? 'border-gray-700 bg-gray-800/50' 
          : 'border-gray-800 bg-gray-800/30 hover:border-gray-700'
    }`}>
      {/* Header Row */}
      <button
        onClick={onToggle}
        className="w-full flex items-center gap-3 px-4 py-3 hover:bg-gray-700/20 transition-colors text-left"
      >
        {/* Step Number */}
        <div className={`w-8 h-8 rounded-lg flex items-center justify-center flex-shrink-0 ${
          hasControlPoints 
            ? 'bg-rose-500/20 text-rose-400' 
            : 'bg-gray-800 text-gray-400'
        }`}>
          <span className="text-sm font-semibold">{index + 1}</span>
        </div>
        
        {/* Title & Badges */}
        <div className="flex-1 min-w-0">
          <h3 className="text-sm font-medium text-gray-200 truncate">{title}</h3>
          {hasControlPoints && (
            <div className="mt-1 hidden sm:block">
              <ControlPointBadges step={step} size="small" />
            </div>
          )}
        </div>
        
        {/* Meta Pills */}
        <div className="flex items-center gap-1.5 flex-shrink-0">
          {step.temperature?.value && (
            <div className="hidden sm:flex items-center gap-1 px-2 py-1 rounded-md bg-orange-500/10 text-orange-400">
              <Thermometer className="w-3 h-3" />
              <span className="text-xs font-medium">{step.temperature.value}°</span>
            </div>
          )}
          
          {step.time_in_minutes && step.time_in_minutes > 0 && (
            <div className="hidden sm:flex items-center gap-1 px-2 py-1 rounded-md bg-gray-800 text-gray-400">
              <Timer className="w-3 h-3" />
              <span className="text-xs">{step.time_in_minutes}m</span>
            </div>
          )}
          
          {hasMedia && (
            <div className="hidden sm:flex items-center gap-1 px-2 py-1 rounded-md bg-gray-800 text-gray-500">
              <ImageIcon className="w-3 h-3" />
              <span className="text-xs">{mediaCount}</span>
            </div>
          )}
          
          <ChevronDown className={`w-4 h-4 text-gray-600 transition-transform ${isExpanded ? 'rotate-180' : ''}`} />
        </div>
      </button>

      {/* Expanded Content Area - Gold Standard: border-t separator + subtle bg for density */}
      {isExpanded && (
        <div className="px-4 pb-4 pt-4 border-t border-gray-700/50 bg-gray-950/40">
          {/* Mobile Control Points */}
          {hasControlPoints && (
            <div className="mb-3 sm:hidden">
              <ControlPointBadges step={step} />
            </div>
          )}
          
          {/* Mobile Meta */}
          <div className="flex flex-wrap gap-2 mb-3 sm:hidden">
            {step.temperature?.value && (
              <div className="flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg bg-orange-500/10 border border-orange-500/20">
                <Thermometer className="w-4 h-4 text-orange-400" />
                <span className="text-sm text-orange-400 font-medium">
                  {step.temperature.value}°{step.temperature.unit}
                </span>
              </div>
            )}
            {step.time_in_minutes && step.time_in_minutes > 0 && (
              <div className="flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg bg-amber-500/10 border border-amber-500/20">
                <Timer className="w-4 h-4 text-amber-400" />
                <span className="text-sm text-amber-300">{step.time_in_minutes} min</span>
              </div>
            )}
          </div>
          
          {/* Instruction */}
          <RichTextRenderer html={step.instruction} blocks={blocks} />
          
          {/* Delay */}
          {step.delay?.value && step.delay.value > 0 && (
            <div className="mt-3 flex items-center gap-2 p-3 rounded-lg bg-purple-500/10 border border-purple-500/20">
              <Hourglass className="w-4 h-4 text-purple-400" />
              <span className="text-sm text-purple-300">
                Wait {formatDelay(step.delay)} before next step
              </span>
            </div>
          )}
          
          {/* Notes */}
          {step.notes && (
            <div className="mt-3 p-3 rounded-lg bg-gray-800/30 border border-gray-700/30">
              <div className="flex items-center gap-2 mb-1.5">
                <Info className="w-3.5 h-3.5 text-gray-500" />
                <span className="text-xs font-medium text-gray-500 uppercase tracking-wider">Notes</span>
              </div>
              <p className="text-sm text-gray-400">{step.notes}</p>
            </div>
          )}
          
          {/* Media */}
          {hasMedia && <MediaGallery media={step.media!} />}
        </div>
      )}
    </div>
  );
};

// ============================================================================
// STAGE HEADER COMPONENT (Compact Mode)
// ============================================================================

interface StageHeaderProps {
  stage: RecipeStage;
  stepCount: number;
}

const StageHeader: React.FC<StageHeaderProps> = ({ stage, stepCount }) => (
  <div className="flex items-center gap-3 py-3">
    <div className="flex items-center gap-2">
      <div className="w-2.5 h-2.5 rounded-full bg-purple-500/60" />
      <h4 className="text-sm font-semibold text-purple-400 uppercase tracking-wider">
        {stage.name}
      </h4>
    </div>
    <div className="flex-1 h-px bg-gradient-to-r from-purple-500/30 to-transparent" />
    <div className="flex items-center gap-2 text-xs text-gray-500">
      <span>{stepCount} step{stepCount !== 1 ? 's' : ''}</span>
      {stage.total_time && stage.total_time > 0 && (
        <>
          <span>•</span>
          <span>{formatDuration(stage.total_time)}</span>
        </>
      )}
      {stage.is_prep_list_task && (
        <span className="px-1.5 py-0.5 rounded bg-emerald-500/20 text-emerald-400 text-[10px] font-medium">
          PREP
        </span>
      )}
    </div>
  </div>
);

// ============================================================================
// GUIDED MODE - Horizontal Scrolling Book (Inline or Fullscreen)
// ============================================================================

interface GuidedViewProps {
  recipe: Recipe;
  blocks: InstructionBlockTemplate[];
  isFullscreen: boolean;
  onToggleFullscreen: () => void;
  onClose: () => void;
}

const GuidedView: React.FC<GuidedViewProps> = ({ recipe, blocks, isFullscreen, onToggleFullscreen, onClose }) => {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const [currentPage, setCurrentPage] = useState(0);
  
  const steps = recipe.steps || [];
  const totalPages = steps.length + 2;
  
  const heroImage = useMemo(() => {
    const recipePrimary = recipe.media?.find(m => m.is_primary && m.type === 'image');
    if (recipePrimary) return recipePrimary.url;
    for (const step of steps) {
      const stepImage = step.media?.find(m => m.type === 'image');
      if (stepImage) return stepImage.url;
    }
    return null;
  }, [recipe.media, steps]);
  
  const totalTime = calculateTotalTime(steps);
  
  const handleScroll = useCallback(() => {
    if (!scrollContainerRef.current) return;
    const container = scrollContainerRef.current;
    const pageWidth = container.clientWidth;
    const scrollLeft = container.scrollLeft;
    const newPage = Math.round(scrollLeft / pageWidth);
    setCurrentPage(newPage);
  }, []);
  
  const goToPage = useCallback((page: number) => {
    if (!scrollContainerRef.current) return;
    const container = scrollContainerRef.current;
    const pageWidth = container.clientWidth;
    container.scrollTo({ left: page * pageWidth, behavior: 'smooth' });
  }, []);
  
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        e.preventDefault();
        goToPage(Math.min(currentPage + 1, totalPages - 1));
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        e.preventDefault();
        goToPage(Math.max(currentPage - 1, 0));
      } else if (e.key === 'Escape') {
        if (isFullscreen) {
          onToggleFullscreen();
        } else {
          onClose();
        }
      } else if (e.key === 'Home') {
        e.preventDefault();
        goToPage(0);
      } else if (e.key === 'End') {
        e.preventDefault();
        goToPage(totalPages - 1);
      } else if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        onToggleFullscreen();
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [currentPage, totalPages, goToPage, onClose, isFullscreen, onToggleFullscreen]);

  const containerHeight = isFullscreen ? 'h-screen' : 'h-[600px] sm:h-[700px]';

  return (
    <div className={`${containerHeight} bg-neutral-950 flex flex-col rounded-xl overflow-hidden border border-neutral-800/50`}>
      {/* Top Navigation Bar */}
      <div className="flex-shrink-0 bg-neutral-900/80 backdrop-blur-sm border-b border-neutral-800/50 z-10">
        <div className="flex items-center justify-between px-4 py-3">
          <div className="flex items-center gap-3">
            {isFullscreen && (
              <button
                onClick={onClose}
                className="w-8 h-8 rounded-full bg-neutral-800/80 hover:bg-neutral-700/80 flex items-center justify-center text-neutral-400 hover:text-neutral-200 transition-all"
              >
                <X className="w-4 h-4" />
              </button>
            )}
            <div>
              <h1 className="text-sm font-medium text-neutral-200 truncate max-w-[150px] sm:max-w-[300px]">{recipe.name}</h1>
              <p className="text-xs text-neutral-600">Guided Mode</p>
            </div>
          </div>
          
          <div className="flex items-center gap-3">
            {/* Page Dots */}
            <div className="hidden md:flex items-center gap-1">
              {Array.from({ length: totalPages }).map((_, i) => (
                <button
                  key={i}
                  onClick={() => goToPage(i)}
                  className={`h-1.5 rounded-full transition-all ${
                    i === currentPage 
                      ? 'bg-amber-500 w-5' 
                      : 'bg-neutral-700 w-1.5 hover:bg-neutral-600'
                  }`}
                />
              ))}
            </div>
            
            {/* Page Counter */}
            <span className="text-sm text-neutral-500">
              {currentPage === 0 ? 'Cover' : currentPage === totalPages - 1 ? 'End' : `${currentPage}`}
              <span className="text-neutral-700 mx-1">/</span>
              <span className="text-neutral-600">{steps.length}</span>
            </span>
            
            {/* Nav Arrows */}
            <div className="flex items-center gap-1">
              <button
                onClick={() => goToPage(Math.max(currentPage - 1, 0))}
                disabled={currentPage === 0}
                className={`w-7 h-7 rounded-md flex items-center justify-center transition-all ${
                  currentPage === 0 
                    ? 'text-neutral-800 cursor-not-allowed' 
                    : 'text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800/50'
                }`}
              >
                <ChevronLeft className="w-4 h-4" />
              </button>
              <button
                onClick={() => goToPage(Math.min(currentPage + 1, totalPages - 1))}
                disabled={currentPage === totalPages - 1}
                className={`w-7 h-7 rounded-md flex items-center justify-center transition-all ${
                  currentPage === totalPages - 1 
                    ? 'text-neutral-800 cursor-not-allowed' 
                    : 'text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800/50'
                }`}
              >
                <ChevronRight className="w-4 h-4" />
              </button>
            </div>
            
            {/* Fullscreen Toggle */}
            <button
              onClick={onToggleFullscreen}
              className="w-7 h-7 rounded-md flex items-center justify-center text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800/50 transition-all"
              title={isFullscreen ? 'Exit fullscreen (F)' : 'Fullscreen (F)'}
            >
              {isFullscreen ? <Minimize2 className="w-4 h-4" /> : <Maximize2 className="w-4 h-4" />}
            </button>
          </div>
        </div>
      </div>

      {/* Horizontal Scroll Container */}
      <div
        ref={scrollContainerRef}
        onScroll={handleScroll}
        className="flex-1 overflow-x-auto overflow-y-hidden snap-x snap-mandatory scroll-smooth"
        style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
      >
        <div className="flex h-full" style={{ width: `${totalPages * 100}%` }}>
          
          {/* TITLE PAGE */}
          <div 
            className="w-full h-full flex-shrink-0 snap-start snap-always flex items-center justify-center relative overflow-hidden" 
            style={{ width: `${100 / totalPages}%` }}
          >
            {heroImage && (
              <>
                <img src={heroImage} alt="" className="absolute inset-0 w-full h-full object-cover" />
                <div className="absolute inset-0 bg-gradient-to-r from-neutral-950/95 via-neutral-950/70 to-neutral-950/50" />
              </>
            )}
            
            <div className="relative z-10 max-w-xl mx-auto px-8 text-center">
              <div className="w-14 h-14 rounded-xl bg-neutral-800/50 border border-neutral-700/50 flex items-center justify-center mx-auto mb-6 backdrop-blur-sm">
                <BookOpen className="w-7 h-7 text-amber-500/80" />
              </div>
              
              <h1 className="text-2xl sm:text-3xl lg:text-4xl font-light text-neutral-100 mb-4 leading-tight tracking-tight">
                {recipe.name}
              </h1>
              
              {recipe.description && (
                <p className="text-sm sm:text-base text-neutral-400 mb-6 leading-relaxed font-light">
                  {recipe.description}
                </p>
              )}
              
              <div className="flex items-center justify-center gap-6 text-neutral-500">
                {totalTime > 0 && (
                  <div className="flex items-center gap-2">
                    <Timer className="w-4 h-4 text-amber-500/60" />
                    <span className="text-sm font-light">{formatDuration(totalTime)}</span>
                  </div>
                )}
                <div className="flex items-center gap-2">
                  <ListOrdered className="w-4 h-4 text-amber-500/60" />
                  <span className="text-sm font-light">{steps.length} steps</span>
                </div>
              </div>
              
              <div className="mt-10 flex items-center justify-center gap-2 text-neutral-700">
                <span className="text-xs font-light">swipe or use arrows</span>
                <ChevronRight className="w-3 h-3" />
              </div>
            </div>
          </div>

          {/* STEP PAGES */}
          {steps.map((step, index) => {
            const title = extractStepTitle(step.instruction, step.custom_step_label);
            const hasControlPoints = step.is_critical_control_point || step.is_quality_control_point || (step.warning_level && step.warning_level !== 'low');
            const stepImage = step.media?.find(m => m.type === 'image');
            
            return (
              <div
                key={step.id}
                className="w-full h-full flex-shrink-0 snap-start snap-always flex items-stretch overflow-hidden"
                style={{ width: `${100 / totalPages}%` }}
              >
                <div className={`flex flex-col lg:flex-row w-full h-full ${index % 2 === 0 ? '' : 'lg:flex-row-reverse'}`}>
                  
                  {/* Image Column */}
                  <div className={`lg:w-1/2 h-2/5 lg:h-full flex-shrink-0 relative ${stepImage ? '' : 'hidden lg:flex lg:items-center lg:justify-center bg-neutral-900/30'}`}>
                    {stepImage ? (
                      <>
                        <img 
                          src={stepImage.url} 
                          alt={stepImage.title || `Step ${index + 1}`}
                          className="absolute inset-0 w-full h-full object-cover"
                        />
                        <div className={`absolute inset-0 bg-gradient-to-${index % 2 === 0 ? 'r' : 'l'} from-transparent via-transparent to-neutral-950/80 hidden lg:block`} />
                        <div className="absolute inset-0 bg-gradient-to-t from-neutral-950 via-neutral-950/20 to-transparent lg:hidden" />
                      </>
                    ) : (
                      <div className="text-center text-neutral-800">
                        <ChefHat className="w-10 h-10 mx-auto" />
                      </div>
                    )}
                  </div>
                  
                  {/* Content Column */}
                  <div className="flex-1 flex items-center justify-center p-5 sm:p-8 lg:p-10 overflow-y-auto bg-neutral-950">
                    <div className="max-w-md w-full">
                      {hasControlPoints && (
                        <div className="mb-3">
                          <ControlPointBadges step={step} size="normal" subtle />
                        </div>
                      )}
                      
                      <div className="flex items-start gap-3 mb-4">
                        <div className={`w-10 h-10 sm:w-12 sm:h-12 rounded-xl flex items-center justify-center flex-shrink-0 ${
                          hasControlPoints 
                            ? 'bg-rose-500/10 border border-rose-500/20' 
                            : 'bg-neutral-800/50 border border-neutral-700/50'
                        }`}>
                          <span className={`text-lg sm:text-xl font-light ${hasControlPoints ? 'text-rose-400/80' : 'text-amber-500/80'}`}>
                            {index + 1}
                          </span>
                        </div>
                        <div className="pt-1 flex-1">
                          <h2 className="text-base sm:text-lg lg:text-xl font-medium text-neutral-100 leading-tight tracking-tight">
                            {title}
                          </h2>
                          <div className="flex flex-wrap items-center gap-3 mt-1.5">
                            {step.time_in_minutes && step.time_in_minutes > 0 && (
                              <span className="flex items-center gap-1 text-neutral-600">
                                <Timer className="w-3 h-3" />
                                <span className="text-xs font-light">{step.time_in_minutes} min</span>
                              </span>
                            )}
                            {step.temperature?.value && (
                              <span className="flex items-center gap-1 text-neutral-600">
                                <Thermometer className="w-3 h-3" />
                                <span className="text-xs font-light">{step.temperature.value}°{step.temperature.unit}</span>
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                      
                      <RichTextRenderer html={step.instruction} blocks={blocks} size="guided" subtle />
                      
                      {step.delay?.value && step.delay.value > 0 && (
                        <div className="mt-4 flex items-center gap-2 p-2.5 rounded-lg bg-neutral-900/50 border border-neutral-800/50">
                          <Hourglass className="w-3.5 h-3.5 text-neutral-600" />
                          <span className="text-sm text-neutral-500 font-light">
                            Wait {formatDelay(step.delay)}
                          </span>
                        </div>
                      )}
                      
                      {step.notes && (
                        <div className="mt-4 p-2.5 rounded-lg bg-neutral-900/30 border border-neutral-800/30">
                          <div className="flex items-center gap-1.5 mb-1">
                            <Info className="w-3 h-3 text-neutral-700" />
                            <span className="text-[10px] font-medium text-neutral-700 uppercase tracking-wider">Note</span>
                          </div>
                          <p className="text-sm text-neutral-500 font-light italic">{step.notes}</p>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            );
          })}

          {/* COMPLETION PAGE */}
          <div 
            className="w-full h-full flex-shrink-0 snap-start snap-always flex items-center justify-center bg-neutral-950" 
            style={{ width: `${100 / totalPages}%` }}
          >
            <div className="text-center px-8 max-w-sm">
              <div className="w-16 h-16 rounded-full bg-neutral-900/50 border border-neutral-800/50 flex items-center justify-center mx-auto mb-6">
                <CheckCircle className="w-8 h-8 text-emerald-500/60" />
              </div>
              
              <h2 className="text-xl sm:text-2xl font-light text-neutral-200 mb-3 tracking-tight">
                Recipe Complete
              </h2>
              
              <p className="text-sm text-neutral-600 mb-8 font-light">
                {recipe.name}
              </p>
              
              <div className="flex flex-col sm:flex-row items-center justify-center gap-2">
                <button
                  onClick={() => goToPage(0)}
                  className="flex items-center gap-2 px-4 py-2 rounded-lg bg-neutral-900/50 text-neutral-400 hover:text-neutral-200 hover:bg-neutral-800/50 transition-all border border-neutral-800/50 text-sm"
                >
                  <ChevronLeft className="w-4 h-4" />
                  <span className="font-light">Restart</span>
                </button>
                <button
                  onClick={onClose}
                  className="flex items-center gap-2 px-4 py-2 rounded-lg bg-amber-500/10 text-amber-500/80 hover:text-amber-400 hover:bg-amber-500/20 transition-all border border-amber-500/20 text-sm"
                >
                  <X className="w-4 h-4" />
                  <span className="font-light">Exit</span>
                </button>
              </div>
            </div>
          </div>
          
        </div>
      </div>

      {/* Bottom Page Indicator (Mobile) */}
      <div className="flex-shrink-0 md:hidden bg-neutral-900/80 border-t border-neutral-800/50 py-2 px-4">
        <div className="flex items-center justify-center gap-1">
          {Array.from({ length: totalPages }).map((_, i) => (
            <button
              key={i}
              onClick={() => goToPage(i)}
              className={`h-1 rounded-full transition-all ${
                i === currentPage 
                  ? 'bg-amber-500/80 w-4' 
                  : 'bg-neutral-800 w-1 hover:bg-neutral-700'
              }`}
            />
          ))}
        </div>
      </div>

      <style>{`.snap-x::-webkit-scrollbar { display: none; }`}</style>
    </div>
  );
};

// ============================================================================
// FOCUS VIEW - Full Screen Immersive Cooking Mode
// ============================================================================

interface FocusViewProps {
  steps: RecipeStep[];
  recipeName: string;
  blocks: InstructionBlockTemplate[];
  onClose: () => void;
}

const FocusView: React.FC<FocusViewProps> = ({ steps, recipeName, blocks, onClose }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isClosing, setIsClosing] = useState(false); // Hide UI during close
  const containerRef = useRef<HTMLDivElement>(null);
  const isClosingRef = useRef(false); // Prevent double-close
  
  const [timerSeconds, setTimerSeconds] = useState(0);
  const [timerRunning, setTimerRunning] = useState(false);
  const [timerComplete, setTimerComplete] = useState(false);

  const step = steps[currentStep];
  const progress = ((currentStep + 1) / steps.length) * 100;
  const title = extractStepTitle(step.instruction, step.custom_step_label);
  const stepHasTimer = step.time_in_minutes && step.time_in_minutes > 0;
  const isComplete = completedSteps.has(currentStep);
  const hasMedia = step.media && step.media.length > 0;

  useEffect(() => {
    if (stepHasTimer) {
      setTimerSeconds(step.time_in_minutes! * 60);
      setTimerRunning(false);
      setTimerComplete(false);
    }
  }, [currentStep, step.time_in_minutes, stepHasTimer]);

  useEffect(() => {
    if (!timerRunning || timerSeconds <= 0) return;
    
    const interval = setInterval(() => {
      setTimerSeconds(s => {
        if (s <= 1) {
          setTimerRunning(false);
          setTimerComplete(true);
          return 0;
        }
        return s - 1;
      });
    }, 1000);
    
    return () => clearInterval(interval);
  }, [timerRunning, timerSeconds]);

  const formatTime = (s: number) => {
    const mins = Math.floor(s / 60);
    const secs = s % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const resetTimer = () => {
    if (stepHasTimer) {
      setTimerSeconds(step.time_in_minutes! * 60);
      setTimerRunning(false);
      setTimerComplete(false);
    }
  };

  const enterFullscreen = useCallback(async () => {
    try {
      if (containerRef.current?.requestFullscreen) {
        await containerRef.current.requestFullscreen();
        setIsFullscreen(true);
      } else if ((containerRef.current as any)?.webkitRequestFullscreen) {
        await (containerRef.current as any).webkitRequestFullscreen();
        setIsFullscreen(true);
      }
    } catch (err) {
      console.warn('Fullscreen not supported:', err);
    }
  }, []);

  // Single clean close handler - prevents double-close
  const handleClose = useCallback(async () => {
    if (isClosingRef.current) return; // Already closing
    isClosingRef.current = true;
    setIsClosing(true); // Hide UI immediately
    
    // Exit fullscreen if still active
    try {
      if (document.fullscreenElement || (document as any).webkitFullscreenElement) {
        if (document.exitFullscreen) await document.exitFullscreen();
        else if ((document as any).webkitExitFullscreen) await (document as any).webkitExitFullscreen();
      }
    } catch (err) {}
    
    // Call onClose immediately - UI is already hidden
    onClose();
  }, [onClose]);

  // Auto-enter fullscreen immediately
  useEffect(() => {
    const timeout = setTimeout(() => enterFullscreen(), 50);
    return () => clearTimeout(timeout);
  }, [enterFullscreen]);

  // Track fullscreen changes - close when user exits fullscreen via browser (Escape)
  useEffect(() => {
    const handleChange = () => {
      const isNow = !!(document.fullscreenElement || (document as any).webkitFullscreenElement);
      setIsFullscreen(isNow);
      
      // If we exited fullscreen and we're not already closing, trigger close
      if (!isNow && !isClosingRef.current) {
        handleClose();
      }
    };
    
    // Small delay to let initial fullscreen enter complete before listening
    const timeout = setTimeout(() => {
      document.addEventListener('fullscreenchange', handleChange);
      document.addEventListener('webkitfullscreenchange', handleChange);
    }, 100);
    
    return () => {
      clearTimeout(timeout);
      document.removeEventListener('fullscreenchange', handleChange);
      document.removeEventListener('webkitfullscreenchange', handleChange);
    };
  }, [handleClose]);

  // Don't render anything while closing - prevents the flash of inline UI
  if (isClosing) {
    return null;
  }

  const goNext = useCallback(() => {
    if (currentStep < steps.length - 1) setCurrentStep(prev => prev + 1);
  }, [currentStep, steps.length]);

  const goPrev = useCallback(() => {
    if (currentStep > 0) setCurrentStep(prev => prev - 1);
  }, [currentStep]);

  const toggleComplete = useCallback(() => {
    setCompletedSteps(prev => {
      const next = new Set(prev);
      next.has(currentStep) ? next.delete(currentStep) : next.add(currentStep);
      return next;
    });
  }, [currentStep]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'ArrowRight') { e.preventDefault(); goNext(); }
      else if (e.key === 'ArrowLeft') { e.preventDefault(); goPrev(); }
      else if (e.key === 'Escape') { 
        e.preventDefault(); 
        handleClose(); // handleClose manages fullscreen exit internally
      }
      else if (e.key === 'Enter') { toggleComplete(); }
      else if (e.key === ' ' && stepHasTimer) { e.preventDefault(); setTimerRunning(r => !r); }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [goNext, goPrev, handleClose, toggleComplete, stepHasTimer]);

  return (
    <div ref={containerRef} className="fixed inset-0 z-50 bg-gray-950 flex flex-col">
      {/* Top Bar */}
      <div className="flex-shrink-0 bg-gray-900/80 backdrop-blur-sm border-b border-gray-800">
        <div className="h-1 bg-gray-800">
          <div className="h-full bg-gradient-to-r from-amber-500 to-amber-400 transition-all duration-300" style={{ width: `${progress}%` }} />
        </div>
        
        <div className="flex items-center justify-between px-4 sm:px-6 py-3">
          <div className="flex items-center gap-3 min-w-0">
            <button onClick={handleClose} className="w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 flex items-center justify-center text-gray-400 hover:text-white transition-all flex-shrink-0">
              <X className="w-5 h-5" />
            </button>
            <div className="min-w-0">
              <h1 className="text-sm sm:text-base font-semibold text-white truncate">{recipeName}</h1>
              <p className="text-xs text-gray-500">Focus Mode</p>
            </div>
          </div>
          
          <div className="flex items-center gap-2 sm:gap-4">
            <div className="hidden md:flex items-center gap-1.5">
              {steps.map((_, i) => (
                <button key={i} onClick={() => setCurrentStep(i)}
                  className={`w-2.5 h-2.5 rounded-full transition-all ${i === currentStep ? 'bg-amber-500 scale-125' : completedSteps.has(i) ? 'bg-emerald-500' : 'bg-gray-700 hover:bg-gray-600'}`}
                />
              ))}
            </div>
            <span className="text-sm font-medium text-white">{currentStep + 1}<span className="text-gray-500">/{steps.length}</span></span>
            {!isFullscreen && (
              <button onClick={enterFullscreen} className="w-8 h-8 rounded-full bg-gray-800 hover:bg-gray-700 flex items-center justify-center text-gray-400 hover:text-white">
                <Maximize2 className="w-4 h-4" />
              </button>
            )}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 overflow-y-auto">
        <div className="max-w-3xl mx-auto px-4 sm:px-6 py-6 sm:py-10">
          {(step.is_critical_control_point || step.is_quality_control_point || (step.warning_level && step.warning_level !== 'low')) && (
            <div className="mb-4">
              <ControlPointBadges step={step} />
            </div>
          )}

          <div className="flex items-start gap-3 sm:gap-4 mb-6">
            <div className={`w-12 h-12 sm:w-14 sm:h-14 lg:w-16 lg:h-16 rounded-xl flex items-center justify-center text-xl sm:text-2xl font-bold flex-shrink-0 ${
              isComplete ? 'bg-emerald-500/20 text-emerald-400 ring-2 ring-emerald-500/50' : 'bg-amber-500/20 text-amber-400'
            }`}>
              {isComplete ? <Check className="w-6 h-6 sm:w-7 sm:h-7" /> : currentStep + 1}
            </div>
            <div className="pt-1 flex-1">
              <h2 className="text-lg sm:text-xl lg:text-2xl font-semibold text-white leading-tight">{title}</h2>
              {isComplete && <span className="text-emerald-400 text-sm font-medium">Completed</span>}
              
              <div className="flex flex-wrap gap-2 mt-2">
                {step.temperature?.value && (
                  <div className="flex items-center gap-1.5 px-2.5 py-1 rounded-lg bg-orange-500/10 border border-orange-500/20">
                    <Thermometer className="w-4 h-4 text-orange-400" />
                    <span className="text-sm text-orange-400 font-medium">
                      {step.temperature.value}°{step.temperature.unit}
                    </span>
                  </div>
                )}
                {stepHasTimer && !timerRunning && !timerComplete && (
                  <div className="flex items-center gap-1.5 px-2.5 py-1 rounded-lg bg-gray-700/50">
                    <Timer className="w-4 h-4 text-gray-400" />
                    <span className="text-sm text-gray-400">{step.time_in_minutes} min</span>
                  </div>
                )}
              </div>
            </div>
          </div>

          <div className={`${isComplete ? 'opacity-60' : ''}`}>
            <RichTextRenderer html={step.instruction} blocks={blocks} size="large" />
          </div>

          {step.delay?.value && step.delay.value > 0 && (
            <div className="mt-6 flex items-center gap-2 p-4 rounded-xl bg-purple-500/10 border border-purple-500/20">
              <Hourglass className="w-5 h-5 text-purple-400" />
              <span className="text-base text-purple-300">
                Wait {formatDelay(step.delay)} before next step
              </span>
            </div>
          )}

          {step.notes && (
            <div className="mt-6 p-4 rounded-xl bg-gray-800/50 border border-gray-700/50">
              <div className="flex items-center gap-2 mb-2">
                <Info className="w-4 h-4 text-gray-400" />
                <span className="text-sm font-medium text-gray-400">Notes</span>
              </div>
              <p className="text-gray-300">{step.notes}</p>
            </div>
          )}

          {hasMedia && (
            <div className="mt-6">
              <MediaGallery media={step.media!} size="large" />
            </div>
          )}
        </div>
      </div>

      {/* Bottom Action Bar */}
      <div className="flex-shrink-0 bg-gray-900/95 backdrop-blur-sm border-t border-gray-800">
        <div className="max-w-3xl mx-auto px-4 sm:px-6 py-3 sm:py-4">
          <div className="flex items-center justify-between gap-2 sm:gap-4">
            <button
              onClick={goPrev}
              disabled={currentStep === 0}
              className={`w-12 sm:w-auto sm:px-4 h-12 rounded-xl font-medium transition-all flex items-center justify-center gap-2 ${
                currentStep === 0 ? 'bg-gray-800/50 text-gray-600 cursor-not-allowed' : 'bg-gray-800 text-white hover:bg-gray-700'
              }`}
            >
              <ChevronLeft className="w-5 h-5" />
              <span className="hidden sm:inline">Prev</span>
            </button>

            <div className="flex-1 flex items-center justify-center gap-2 sm:gap-3">
              {stepHasTimer ? (
                <>
                  <div className={`flex items-center gap-2 px-3 sm:px-4 py-2 rounded-xl border ${
                    timerComplete 
                      ? 'bg-emerald-500/20 border-emerald-500/30 text-emerald-400' 
                      : timerRunning 
                        ? 'bg-amber-500/20 border-amber-500/30 text-amber-400'
                        : 'bg-gray-800 border-gray-700 text-white'
                  }`}>
                    <Timer className="w-4 h-4 sm:w-5 sm:h-5" />
                    <span className="font-mono text-lg sm:text-xl font-bold">{formatTime(timerSeconds)}</span>
                  </div>
                  
                  <button
                    onClick={() => setTimerRunning(r => !r)}
                    disabled={timerComplete}
                    className={`w-10 h-10 sm:w-12 sm:h-12 rounded-full flex items-center justify-center transition-all ${
                      timerComplete
                        ? 'bg-emerald-500/20 text-emerald-400'
                        : timerRunning
                          ? 'bg-amber-500/30 text-amber-400 hover:bg-amber-500/40'
                          : 'bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30'
                    }`}
                  >
                    {timerComplete ? <Check className="w-5 h-5" /> : timerRunning ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5 ml-0.5" />}
                  </button>
                  
                  <button
                    onClick={resetTimer}
                    className="w-10 h-10 rounded-full bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-white flex items-center justify-center transition-all"
                  >
                    <RotateCcw className="w-4 h-4" />
                  </button>
                </>
              ) : (
                <button
                  onClick={toggleComplete}
                  className={`flex items-center gap-2 px-4 sm:px-6 py-2.5 sm:py-3 rounded-xl font-medium transition-all ${
                    isComplete
                      ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30'
                      : 'bg-gray-800 text-gray-300 border border-gray-700 hover:bg-gray-700 hover:text-white'
                  }`}
                >
                  {isComplete ? <Check className="w-5 h-5" /> : <Circle className="w-5 h-5" />}
                  <span className="hidden sm:inline">{isComplete ? 'Done' : 'Mark Done'}</span>
                </button>
              )}
            </div>

            <button
              onClick={goNext}
              disabled={currentStep === steps.length - 1}
              className={`w-12 sm:w-auto sm:px-4 h-12 rounded-xl font-medium transition-all flex items-center justify-center gap-2 ${
                currentStep === steps.length - 1 
                  ? 'bg-gray-800/50 text-gray-600 cursor-not-allowed' 
                  : 'bg-amber-500/20 text-amber-400 hover:bg-amber-500/30 border border-amber-500/30'
              }`}
            >
              <span className="hidden sm:inline">Next</span>
              <ChevronRight className="w-5 h-5" />
            </button>
          </div>
          
          <div className="hidden sm:flex mt-3 items-center justify-center gap-4 text-xs text-gray-600">
            <span className="flex items-center gap-1">
              <kbd className="px-1.5 py-0.5 rounded bg-gray-800 text-gray-400 font-mono">←</kbd>
              <kbd className="px-1.5 py-0.5 rounded bg-gray-800 text-gray-400 font-mono">→</kbd>
              Navigate
            </span>
            {stepHasTimer && (
              <span className="flex items-center gap-1">
                <kbd className="px-1.5 py-0.5 rounded bg-gray-800 text-gray-400 font-mono">Space</kbd>
                Timer
              </span>
            )}
            <span className="flex items-center gap-1">
              <kbd className="px-1.5 py-0.5 rounded bg-gray-800 text-gray-400 font-mono">Enter</kbd>
              Done
            </span>
            <span className="flex items-center gap-1">
              <kbd className="px-1.5 py-0.5 rounded bg-gray-800 text-gray-400 font-mono">Esc</kbd>
              Exit
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

// ============================================================================
// UNIFIED VIEW MODE SWITCHER
// ============================================================================

interface ViewModeSwitcherProps {
  mode: ViewMode;
  onChange: (mode: ViewMode) => void;
}

const ViewModeSwitcher: React.FC<ViewModeSwitcherProps> = ({ mode, onChange }) => (
  <div className="flex items-center gap-1 p-1 rounded-lg bg-gray-800/50 border border-gray-700/50">
    <button
      onClick={() => onChange('compact')}
      className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${
        mode === 'compact'
          ? 'bg-gray-700 text-white shadow-sm'
          : 'text-gray-400 hover:text-white hover:bg-gray-700/50'
      }`}
      title="Compact - quick reference"
    >
      <LayoutList className="w-4 h-4" />
      <span className="hidden sm:inline">Compact</span>
    </button>
    <button
      onClick={() => onChange('guided')}
      className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${
        mode === 'guided'
          ? 'bg-amber-500/15 text-amber-400 shadow-sm'
          : 'text-gray-400 hover:text-amber-400 hover:bg-amber-500/10'
      }`}
      title="Guided - cookbook style"
    >
      <BookOpen className="w-4 h-4" />
      <span className="hidden sm:inline">Guided</span>
    </button>
    <button
      onClick={() => onChange('focus')}
      className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${
        mode === 'focus'
          ? 'bg-emerald-500/15 text-emerald-400 shadow-sm'
          : 'text-gray-400 hover:text-emerald-400 hover:bg-emerald-500/10'
      }`}
      title="Focus - fullscreen cooking mode"
    >
      <Focus className="w-4 h-4" />
      <span className="hidden sm:inline">Focus</span>
    </button>
  </div>
);

// ============================================================================
// MAIN COMPONENT
// ============================================================================

export const Method: React.FC<MethodProps> = ({ recipe }) => {
  const { showDiagnostics } = useDiagnostics();
  const [viewMode, setViewMode] = useState<ViewMode>('compact');
  const [guidedFullscreen, setGuidedFullscreen] = useState(false);
  const [expandedStep, setExpandedStep] = useState<number | null>(0);
  const guidedContainerRef = useRef<HTMLDivElement>(null);

  const blocks = useMemo(() => getActiveInstructionBlocks(), []);
  const hasSteps = recipe.steps && recipe.steps.length > 0;
  
  const totalTime = useMemo(() => hasSteps ? calculateTotalTime(recipe.steps) : 0, [recipe.steps, hasSteps]);
  const controlPointCount = useMemo(() => {
    if (!hasSteps) return 0;
    return recipe.steps.filter(s => s.is_critical_control_point || s.is_quality_control_point).length;
  }, [recipe.steps, hasSteps]);
  
  const stepGroups = useMemo(() => {
    if (!hasSteps) return [];
    return groupStepsByStage(recipe.steps, recipe.stages || []);
  }, [recipe.steps, recipe.stages, hasSteps]);

  // Guided fullscreen handlers
  const enterGuidedFullscreen = useCallback(async () => {
    try {
      if (guidedContainerRef.current?.requestFullscreen) {
        await guidedContainerRef.current.requestFullscreen();
        setGuidedFullscreen(true);
      } else if ((guidedContainerRef.current as any)?.webkitRequestFullscreen) {
        await (guidedContainerRef.current as any).webkitRequestFullscreen();
        setGuidedFullscreen(true);
      }
    } catch (err) {
      console.warn('Fullscreen not supported:', err);
    }
  }, []);

  const exitGuidedFullscreen = useCallback(async () => {
    try {
      if (document.fullscreenElement) await document.exitFullscreen();
      else if ((document as any).webkitExitFullscreen) await (document as any).webkitExitFullscreen();
      setGuidedFullscreen(false);
    } catch (err) {}
  }, []);

  const toggleGuidedFullscreen = useCallback(() => {
    if (guidedFullscreen) {
      exitGuidedFullscreen();
    } else {
      enterGuidedFullscreen();
    }
  }, [guidedFullscreen, enterGuidedFullscreen, exitGuidedFullscreen]);

  // Handle fullscreen change events for guided mode
  useEffect(() => {
    const handleChange = () => {
      const isNow = !!(document.fullscreenElement || (document as any).webkitFullscreenElement);
      setGuidedFullscreen(isNow);
    };
    document.addEventListener('fullscreenchange', handleChange);
    document.addEventListener('webkitfullscreenchange', handleChange);
    return () => {
      document.removeEventListener('fullscreenchange', handleChange);
      document.removeEventListener('webkitfullscreenchange', handleChange);
    };
  }, []);

  // Close guided mode
  const closeGuidedMode = useCallback(async () => {
    await exitGuidedFullscreen();
    setViewMode('compact');
  }, [exitGuidedFullscreen]);

  return (
    <>
      <div>
        {showDiagnostics && (
          <div className="text-xs text-gray-500 font-mono mb-4">
            src/features/recipes/components/RecipeViewer/components/Method.tsx
          </div>
        )}

        {/* Subheader */}
        <div className="subheader mb-6">
          <div className="subheader-row">
            <div className="subheader-left">
              <div className="subheader-icon-box amber">
                <ListOrdered className="w-5 h-5" />
              </div>
              <div>
                <h3 className="subheader-title">Method</h3>
                <p className="subheader-subtitle">
                  {hasSteps 
                    ? `${recipe.steps.length} step${recipe.steps.length !== 1 ? 's' : ''} to complete`
                    : 'No steps defined'
                  }
                </p>
              </div>
            </div>
            
            <div className="subheader-right flex-wrap">
              {hasSteps && (
                <>
                  {totalTime > 0 && (
                    <span className="subheader-pill hidden lg:flex">
                      <Timer className="w-3.5 h-3.5 text-amber-400" />
                      <span className="subheader-pill-value">{formatDuration(totalTime)}</span>
                    </span>
                  )}
                  
                  {controlPointCount > 0 && (
                    <span className="subheader-pill hidden lg:flex">
                      <ShieldAlert className="w-3.5 h-3.5 text-rose-400" />
                      <span className="subheader-pill-value text-rose-400">{controlPointCount}</span>
                      <span className="subheader-pill-label">CCP</span>
                    </span>
                  )}
                  
                  <div className="subheader-divider hidden lg:block" />
                  
                  <ViewModeSwitcher mode={viewMode} onChange={setViewMode} />
                </>
              )}
            </div>
          </div>
        </div>

        {/* COMPACT MODE */}
        {viewMode === 'compact' && hasSteps && (
          <div className="space-y-6">
            {stepGroups.map((group) => (
              <div key={group.stage?.id || 'unstaged'}>
                {group.stage && (
                  <StageHeader stage={group.stage} stepCount={group.steps.length} />
                )}
                
                <div className="space-y-2">
                  {group.steps.map(({ step, originalIndex }) => (
                    <CompactStepCard
                      key={step.id}
                      step={step}
                      index={originalIndex}
                      blocks={blocks}
                      isExpanded={expandedStep === originalIndex}
                      onToggle={() => setExpandedStep(expandedStep === originalIndex ? null : originalIndex)}
                    />
                  ))}
                </div>
              </div>
            ))}
          </div>
        )}

        {/* GUIDED MODE - Inline */}
        {viewMode === 'guided' && hasSteps && !guidedFullscreen && (
          <div ref={guidedContainerRef}>
            <GuidedView
              recipe={recipe}
              blocks={blocks}
              isFullscreen={false}
              onToggleFullscreen={toggleGuidedFullscreen}
              onClose={closeGuidedMode}
            />
          </div>
        )}

        {/* Empty State */}
        {!hasSteps && (
          <div className="text-center py-12 bg-gray-800/30 rounded-xl border-2 border-dashed border-gray-700/50">
            <Book className="w-12 h-12 text-gray-600 mx-auto mb-3" />
            <p className="text-gray-400">No steps have been added to this recipe.</p>
          </div>
        )}
      </div>

      {/* GUIDED MODE - Fullscreen Portal */}
      {viewMode === 'guided' && hasSteps && guidedFullscreen && (
        <div ref={guidedContainerRef} className="fixed inset-0 z-50">
          <GuidedView
            recipe={recipe}
            blocks={blocks}
            isFullscreen={true}
            onToggleFullscreen={toggleGuidedFullscreen}
            onClose={closeGuidedMode}
          />
        </div>
      )}

      {/* FOCUS MODE - Always Fullscreen */}
      {viewMode === 'focus' && hasSteps && (
        <FocusView
          steps={recipe.steps}
          recipeName={recipe.name}
          blocks={blocks}
          onClose={() => setViewMode('compact')}
        />
      )}
    </>
  );
};

export default Method;
